# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from ublox_msgs/MgaGAL.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class MgaGAL(genpy.Message):
  _md5sum = "916efe401cfebd852654e34c3cd97512"
  _type = "ublox_msgs/MgaGAL"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# MGA-GAL (0x13 0x02)
# Galileo Ephemeris Assistance
#
# This message allows the delivery of Galileo ephemeris assistance to a 
# receiver. See the description of AssistNow Online for details.
# 

uint8 CLASS_ID = 19
uint8 MESSAGE_ID = 2

uint8 type              # Message type (0x01 for this type)
uint8 version           # Message version (0x00 for this version)
uint8 svid              # Galileo Satellite identifier

uint8 reserved0         # Reserved

uint16 iodNav           # Ephemeris and clock correction issue of Data
int16 deltaN            # Mean motion difference from computed value 
                        # [semi-cir cles/s * 2^-43]
int32 m0                # Mean anomaly at reference time [semi-cir cles 2^-31]
uint32 e                # Eccentricity [2^-33]
uint32 sqrtA            # Square root of the semi-major axis [m^0.5 * 2^-19]
int32 omega0            # Longitude of ascending node of orbital plane at weekly
                        # epoch [semi-cir cles 2^-31]
int32 i0                # inclination angle at reference time 
                        # [semi-cir cles 2^-31]
int32 omega             # Argument of perigee [semi-cir cles 2^-31]
int32 omegaDot          # Rate of change of right ascension 
                        # [semi-cir cles/s 2^-43]
int16 iDot              # Rate of change of inclination angle 
                        # [semi-cir cles/s 2^-43]
int16 cuc               # Amplitude of the cosine harmonic correction term to 
                        # the argument of latitude [radians * 2^-29]
int16 cus               # Amplitude of the sine harmonic correction term to 
                        # the argument of latitude [radians * 2^-29]
int16 crc               # Amplitude of the cosine harmonic correction term 
                        # to the orbit radius [radians * 2^-5]
int16 crs               # Amplitude of the sine harmonic correction term to the 
                        # orbit radius [radians * 2^-5]
int16 cic               # Amplitude of the cosine harmonic correction term to 
                        # the angle of inclination [radians * 2^-29]
int16 cis               # Amplitude of the sine harmonic correction term to the 
                        # angle of inclination [radians * 2^-29]
uint16 toe              # Ephemeris reference time [60 * s]
int32 af0               # clock bias correction coefficient [s * 2^-34]
int32 af1               # SV clock drift correction coefficient [s/s * 2^-46]
int8 af2               # SV clock drift rate correction coefficient 
                        # [s/s^2 * 2^-59]
uint8 sisaindexE1E5b   # Signal-in-Space Accuracy index for dual frequency 
                        # E1-E5b
uint16 toc              # Clock correction data reference Time of Week [60 * s]
int16 bgdE1E5b          # E1-E5b Broadcast Group Delay

uint8[2] reserved1     # Reserved

uint8 healthE1B        # E1-B Signal Health Status
uint8 dataValidityE1B  # E1-B Data Validity Status
uint8 healthE5b        # E5b Signal Health Status
uint8 dataValidityE5b  # E5b Data Validity Status

uint8[4] reserved2     # Reserved"""
  # Pseudo-constants
  CLASS_ID = 19
  MESSAGE_ID = 2

  __slots__ = ['type','version','svid','reserved0','iodNav','deltaN','m0','e','sqrtA','omega0','i0','omega','omegaDot','iDot','cuc','cus','crc','crs','cic','cis','toe','af0','af1','af2','sisaindexE1E5b','toc','bgdE1E5b','reserved1','healthE1B','dataValidityE1B','healthE5b','dataValidityE5b','reserved2']
  _slot_types = ['uint8','uint8','uint8','uint8','uint16','int16','int32','uint32','uint32','int32','int32','int32','int32','int16','int16','int16','int16','int16','int16','int16','uint16','int32','int32','int8','uint8','uint16','int16','uint8[2]','uint8','uint8','uint8','uint8','uint8[4]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       type,version,svid,reserved0,iodNav,deltaN,m0,e,sqrtA,omega0,i0,omega,omegaDot,iDot,cuc,cus,crc,crs,cic,cis,toe,af0,af1,af2,sisaindexE1E5b,toc,bgdE1E5b,reserved1,healthE1B,dataValidityE1B,healthE5b,dataValidityE5b,reserved2

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(MgaGAL, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.type is None:
        self.type = 0
      if self.version is None:
        self.version = 0
      if self.svid is None:
        self.svid = 0
      if self.reserved0 is None:
        self.reserved0 = 0
      if self.iodNav is None:
        self.iodNav = 0
      if self.deltaN is None:
        self.deltaN = 0
      if self.m0 is None:
        self.m0 = 0
      if self.e is None:
        self.e = 0
      if self.sqrtA is None:
        self.sqrtA = 0
      if self.omega0 is None:
        self.omega0 = 0
      if self.i0 is None:
        self.i0 = 0
      if self.omega is None:
        self.omega = 0
      if self.omegaDot is None:
        self.omegaDot = 0
      if self.iDot is None:
        self.iDot = 0
      if self.cuc is None:
        self.cuc = 0
      if self.cus is None:
        self.cus = 0
      if self.crc is None:
        self.crc = 0
      if self.crs is None:
        self.crs = 0
      if self.cic is None:
        self.cic = 0
      if self.cis is None:
        self.cis = 0
      if self.toe is None:
        self.toe = 0
      if self.af0 is None:
        self.af0 = 0
      if self.af1 is None:
        self.af1 = 0
      if self.af2 is None:
        self.af2 = 0
      if self.sisaindexE1E5b is None:
        self.sisaindexE1E5b = 0
      if self.toc is None:
        self.toc = 0
      if self.bgdE1E5b is None:
        self.bgdE1E5b = 0
      if self.reserved1 is None:
        self.reserved1 = b'\0'*2
      if self.healthE1B is None:
        self.healthE1B = 0
      if self.dataValidityE1B is None:
        self.dataValidityE1B = 0
      if self.healthE5b is None:
        self.healthE5b = 0
      if self.dataValidityE5b is None:
        self.dataValidityE5b = 0
      if self.reserved2 is None:
        self.reserved2 = b'\0'*4
    else:
      self.type = 0
      self.version = 0
      self.svid = 0
      self.reserved0 = 0
      self.iodNav = 0
      self.deltaN = 0
      self.m0 = 0
      self.e = 0
      self.sqrtA = 0
      self.omega0 = 0
      self.i0 = 0
      self.omega = 0
      self.omegaDot = 0
      self.iDot = 0
      self.cuc = 0
      self.cus = 0
      self.crc = 0
      self.crs = 0
      self.cic = 0
      self.cis = 0
      self.toe = 0
      self.af0 = 0
      self.af1 = 0
      self.af2 = 0
      self.sisaindexE1E5b = 0
      self.toc = 0
      self.bgdE1E5b = 0
      self.reserved1 = b'\0'*2
      self.healthE1B = 0
      self.dataValidityE1B = 0
      self.healthE5b = 0
      self.dataValidityE5b = 0
      self.reserved2 = b'\0'*4

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_4BHhi2I4i7hH2ibBHh().pack(_x.type, _x.version, _x.svid, _x.reserved0, _x.iodNav, _x.deltaN, _x.m0, _x.e, _x.sqrtA, _x.omega0, _x.i0, _x.omega, _x.omegaDot, _x.iDot, _x.cuc, _x.cus, _x.crc, _x.crs, _x.cic, _x.cis, _x.toe, _x.af0, _x.af1, _x.af2, _x.sisaindexE1E5b, _x.toc, _x.bgdE1E5b))
      _x = self.reserved1
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_2B().pack(*_x))
      else:
        buff.write(_get_struct_2s().pack(_x))
      _x = self
      buff.write(_get_struct_4B().pack(_x.healthE1B, _x.dataValidityE1B, _x.healthE5b, _x.dataValidityE5b))
      _x = self.reserved2
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 66
      (_x.type, _x.version, _x.svid, _x.reserved0, _x.iodNav, _x.deltaN, _x.m0, _x.e, _x.sqrtA, _x.omega0, _x.i0, _x.omega, _x.omegaDot, _x.iDot, _x.cuc, _x.cus, _x.crc, _x.crs, _x.cic, _x.cis, _x.toe, _x.af0, _x.af1, _x.af2, _x.sisaindexE1E5b, _x.toc, _x.bgdE1E5b,) = _get_struct_4BHhi2I4i7hH2ibBHh().unpack(str[start:end])
      start = end
      end += 2
      self.reserved1 = str[start:end]
      _x = self
      start = end
      end += 4
      (_x.healthE1B, _x.dataValidityE1B, _x.healthE5b, _x.dataValidityE5b,) = _get_struct_4B().unpack(str[start:end])
      start = end
      end += 4
      self.reserved2 = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_4BHhi2I4i7hH2ibBHh().pack(_x.type, _x.version, _x.svid, _x.reserved0, _x.iodNav, _x.deltaN, _x.m0, _x.e, _x.sqrtA, _x.omega0, _x.i0, _x.omega, _x.omegaDot, _x.iDot, _x.cuc, _x.cus, _x.crc, _x.crs, _x.cic, _x.cis, _x.toe, _x.af0, _x.af1, _x.af2, _x.sisaindexE1E5b, _x.toc, _x.bgdE1E5b))
      _x = self.reserved1
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_2B().pack(*_x))
      else:
        buff.write(_get_struct_2s().pack(_x))
      _x = self
      buff.write(_get_struct_4B().pack(_x.healthE1B, _x.dataValidityE1B, _x.healthE5b, _x.dataValidityE5b))
      _x = self.reserved2
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 66
      (_x.type, _x.version, _x.svid, _x.reserved0, _x.iodNav, _x.deltaN, _x.m0, _x.e, _x.sqrtA, _x.omega0, _x.i0, _x.omega, _x.omegaDot, _x.iDot, _x.cuc, _x.cus, _x.crc, _x.crs, _x.cic, _x.cis, _x.toe, _x.af0, _x.af1, _x.af2, _x.sisaindexE1E5b, _x.toc, _x.bgdE1E5b,) = _get_struct_4BHhi2I4i7hH2ibBHh().unpack(str[start:end])
      start = end
      end += 2
      self.reserved1 = str[start:end]
      _x = self
      start = end
      end += 4
      (_x.healthE1B, _x.dataValidityE1B, _x.healthE5b, _x.dataValidityE5b,) = _get_struct_4B().unpack(str[start:end])
      start = end
      end += 4
      self.reserved2 = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2B = None
def _get_struct_2B():
    global _struct_2B
    if _struct_2B is None:
        _struct_2B = struct.Struct("<2B")
    return _struct_2B
_struct_2s = None
def _get_struct_2s():
    global _struct_2s
    if _struct_2s is None:
        _struct_2s = struct.Struct("<2s")
    return _struct_2s
_struct_4B = None
def _get_struct_4B():
    global _struct_4B
    if _struct_4B is None:
        _struct_4B = struct.Struct("<4B")
    return _struct_4B
_struct_4BHhi2I4i7hH2ibBHh = None
def _get_struct_4BHhi2I4i7hH2ibBHh():
    global _struct_4BHhi2I4i7hH2ibBHh
    if _struct_4BHhi2I4i7hH2ibBHh is None:
        _struct_4BHhi2I4i7hH2ibBHh = struct.Struct("<4BHhi2I4i7hH2ibBHh")
    return _struct_4BHhi2I4i7hH2ibBHh
_struct_4s = None
def _get_struct_4s():
    global _struct_4s
    if _struct_4s is None:
        _struct_4s = struct.Struct("<4s")
    return _struct_4s
