# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from ublox_msgs/NavRELPOSNED.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class NavRELPOSNED(genpy.Message):
  _md5sum = "fea74cb440387f9a8bcf826c15649585"
  _type = "ublox_msgs/NavRELPOSNED"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# NAV-RELPOSNED (0x01 0x3C)
# Relative Positioning Information in NED frame
# 
# The NED frame is defined as the local topological system at the reference
# station. The relative position vector components in this message, along with
# their associated accuracies, are given in that local topological system
# This message contains the relative position vector from the Reference Station
# to the Rover, including accuracy figures, in the local topological system
# defined at the reference station
#
# Supported on:
#  - u-blox 8 / u-blox M8 from protocol version 20 up to version 23.01 (only
#    with High Precision GNSS products)
#

uint8 CLASS_ID = 1
uint8 MESSAGE_ID = 60

uint8 version                     # Message version (0x00 for this version)
uint8 reserved0                   # Reserved
uint16 refStationId               # Reference Station ID. Must be in the range 
                                  # 0..4095
uint32 iTow                       # GPS time of week of the navigation epoch 
                                  # [ms]

int32 relPosN                     # North component of relative position vector 
                                  # [cm]
int32 relPosE                     # East component of relative position vector
                                  # [cm]
int32 relPosD                     # Down component of relative position vector
                                  # [cm]

int8 relPosHPN                    # High-precision North component of relative
                                  # position vector. [0.1 mm]
                                  # Must be in the range -99 to +99.
                                  # The full North component of the relative
                                  # position vector, in units of cm, is given by
                                  # relPosN + (relPosHPN * 1e-2)
int8 relPosHPE                    # High-precision East component of relative
                                  # position vector. [0.1 mm]
                                  # Must be in the range -99 to +99.
                                  # The full East component of the relative 
                                  # position vector, in units of cm, is given by
                                  # relPosE + (relPosHPE * 1e-2)
int8 relPosHPD                    # High-precision Down component of relative
                                  # position vector. [0.1 mm]
                                  # Must be in the range -99 to +99.
                                  # The full Down component of the relative
                                  # position vector, in units of cm, is given by
                                  # relPosD + (relPosHPD * 1e-2)

uint8 reserved1                   # Reserved

uint32 accN                       # Accuracy of relative position North 
                                  # component [0.1 mm]
uint32 accE                       # Accuracy of relative position East component
                                  # [0.1 mm]
uint32 accD                       # Accuracy of relative position Down component
                                  # [0.1 mm]

uint32 flags
uint32 FLAGS_GNSS_FIX_OK = 1      # A valid fix (i.e within DOP & accuracy 
                                  # masks)
uint32 FLAGS_DIFF_SOLN = 2        # Set if differential corrections were applied
uint32 FLAGS_REL_POS_VALID = 4    # Set if relative position components and
                                  # accuracies are valid
uint32 FLAGS_CARR_SOLN_MASK = 24  # Carrier phase range solution status:
uint32 FLAGS_CARR_SOLN_NONE = 0     # No carrier phase range solution
uint32 FLAGS_CARR_SOLN_FLOAT = 8    # Float solution. No fixed integer carrier 
                                    # phase measurements have been used to
                                    # calculate the solution
uint32 FLAGS_CARR_SOLN_FIXED = 16   # Fixed solution. One or more fixed
                                    # integer carrier phase range measurements
                                    # have been used to calculate the solution
uint32 FLAGS_IS_MOVING = 32       # if the receiver is operating in moving 
                                  # baseline mode (not supported in protocol
                                  # versions less than 20.3)
uint32 FLAGS_REF_POS_MISS = 64    # Set if extrapolated reference position was
                                  # used to compute moving baseline solution 
                                  # this epoch (not supported in protocol
                                  # versions less than 20.3)  
uint32 FLAGS_REF_OBS_MISS = 128   # Set if extrapolated reference observations
                                  # were used to compute moving baseline
                                  # solution this epoch (not supported in
                                  # protocol versions less than 20.3)"""
  # Pseudo-constants
  CLASS_ID = 1
  MESSAGE_ID = 60
  FLAGS_GNSS_FIX_OK = 1
  FLAGS_DIFF_SOLN = 2
  FLAGS_REL_POS_VALID = 4
  FLAGS_CARR_SOLN_MASK = 24
  FLAGS_CARR_SOLN_NONE = 0
  FLAGS_CARR_SOLN_FLOAT = 8
  FLAGS_CARR_SOLN_FIXED = 16
  FLAGS_IS_MOVING = 32
  FLAGS_REF_POS_MISS = 64
  FLAGS_REF_OBS_MISS = 128

  __slots__ = ['version','reserved0','refStationId','iTow','relPosN','relPosE','relPosD','relPosHPN','relPosHPE','relPosHPD','reserved1','accN','accE','accD','flags']
  _slot_types = ['uint8','uint8','uint16','uint32','int32','int32','int32','int8','int8','int8','uint8','uint32','uint32','uint32','uint32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       version,reserved0,refStationId,iTow,relPosN,relPosE,relPosD,relPosHPN,relPosHPE,relPosHPD,reserved1,accN,accE,accD,flags

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(NavRELPOSNED, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.version is None:
        self.version = 0
      if self.reserved0 is None:
        self.reserved0 = 0
      if self.refStationId is None:
        self.refStationId = 0
      if self.iTow is None:
        self.iTow = 0
      if self.relPosN is None:
        self.relPosN = 0
      if self.relPosE is None:
        self.relPosE = 0
      if self.relPosD is None:
        self.relPosD = 0
      if self.relPosHPN is None:
        self.relPosHPN = 0
      if self.relPosHPE is None:
        self.relPosHPE = 0
      if self.relPosHPD is None:
        self.relPosHPD = 0
      if self.reserved1 is None:
        self.reserved1 = 0
      if self.accN is None:
        self.accN = 0
      if self.accE is None:
        self.accE = 0
      if self.accD is None:
        self.accD = 0
      if self.flags is None:
        self.flags = 0
    else:
      self.version = 0
      self.reserved0 = 0
      self.refStationId = 0
      self.iTow = 0
      self.relPosN = 0
      self.relPosE = 0
      self.relPosD = 0
      self.relPosHPN = 0
      self.relPosHPE = 0
      self.relPosHPD = 0
      self.reserved1 = 0
      self.accN = 0
      self.accE = 0
      self.accD = 0
      self.flags = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_2BHI3i3bB4I().pack(_x.version, _x.reserved0, _x.refStationId, _x.iTow, _x.relPosN, _x.relPosE, _x.relPosD, _x.relPosHPN, _x.relPosHPE, _x.relPosHPD, _x.reserved1, _x.accN, _x.accE, _x.accD, _x.flags))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 40
      (_x.version, _x.reserved0, _x.refStationId, _x.iTow, _x.relPosN, _x.relPosE, _x.relPosD, _x.relPosHPN, _x.relPosHPE, _x.relPosHPD, _x.reserved1, _x.accN, _x.accE, _x.accD, _x.flags,) = _get_struct_2BHI3i3bB4I().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_2BHI3i3bB4I().pack(_x.version, _x.reserved0, _x.refStationId, _x.iTow, _x.relPosN, _x.relPosE, _x.relPosD, _x.relPosHPN, _x.relPosHPE, _x.relPosHPD, _x.reserved1, _x.accN, _x.accE, _x.accD, _x.flags))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 40
      (_x.version, _x.reserved0, _x.refStationId, _x.iTow, _x.relPosN, _x.relPosE, _x.relPosD, _x.relPosHPN, _x.relPosHPE, _x.relPosHPD, _x.reserved1, _x.accN, _x.accE, _x.accD, _x.flags,) = _get_struct_2BHI3i3bB4I().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2BHI3i3bB4I = None
def _get_struct_2BHI3i3bB4I():
    global _struct_2BHI3i3bB4I
    if _struct_2BHI3i3bB4I is None:
        _struct_2BHI3i3bB4I = struct.Struct("<2BHI3i3bB4I")
    return _struct_2BHI3i3bB4I
