// Generated by gencpp from file ublox_msgs/CfgNAVX5.msg
// DO NOT EDIT!


#ifndef UBLOX_MSGS_MESSAGE_CFGNAVX5_H
#define UBLOX_MSGS_MESSAGE_CFGNAVX5_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace ublox_msgs
{
template <class ContainerAllocator>
struct CfgNAVX5_
{
  typedef CfgNAVX5_<ContainerAllocator> Type;

  CfgNAVX5_()
    : version(0)
    , mask1(0)
    , mask2(0)
    , reserved1()
    , minSVs(0)
    , maxSVs(0)
    , minCNO(0)
    , reserved2(0)
    , iniFix3D(0)
    , reserved3()
    , ackAiding(0)
    , wknRollover(0)
    , sigAttenCompMode(0)
    , reserved4()
    , usePPP(0)
    , aopCfg(0)
    , reserved5()
    , aopOrbMaxErr(0)
    , reserved6()
    , useAdr(0)  {
      reserved1.assign(0);

      reserved3.assign(0);

      reserved4.assign(0);

      reserved5.assign(0);

      reserved6.assign(0);
  }
  CfgNAVX5_(const ContainerAllocator& _alloc)
    : version(0)
    , mask1(0)
    , mask2(0)
    , reserved1()
    , minSVs(0)
    , maxSVs(0)
    , minCNO(0)
    , reserved2(0)
    , iniFix3D(0)
    , reserved3()
    , ackAiding(0)
    , wknRollover(0)
    , sigAttenCompMode(0)
    , reserved4()
    , usePPP(0)
    , aopCfg(0)
    , reserved5()
    , aopOrbMaxErr(0)
    , reserved6()
    , useAdr(0)  {
  (void)_alloc;
      reserved1.assign(0);

      reserved3.assign(0);

      reserved4.assign(0);

      reserved5.assign(0);

      reserved6.assign(0);
  }



   typedef uint16_t _version_type;
  _version_type version;

   typedef uint16_t _mask1_type;
  _mask1_type mask1;

   typedef uint32_t _mask2_type;
  _mask2_type mask2;

   typedef boost::array<uint8_t, 2>  _reserved1_type;
  _reserved1_type reserved1;

   typedef uint8_t _minSVs_type;
  _minSVs_type minSVs;

   typedef uint8_t _maxSVs_type;
  _maxSVs_type maxSVs;

   typedef uint8_t _minCNO_type;
  _minCNO_type minCNO;

   typedef uint8_t _reserved2_type;
  _reserved2_type reserved2;

   typedef uint8_t _iniFix3D_type;
  _iniFix3D_type iniFix3D;

   typedef boost::array<uint8_t, 2>  _reserved3_type;
  _reserved3_type reserved3;

   typedef uint8_t _ackAiding_type;
  _ackAiding_type ackAiding;

   typedef uint16_t _wknRollover_type;
  _wknRollover_type wknRollover;

   typedef uint8_t _sigAttenCompMode_type;
  _sigAttenCompMode_type sigAttenCompMode;

   typedef boost::array<uint8_t, 5>  _reserved4_type;
  _reserved4_type reserved4;

   typedef uint8_t _usePPP_type;
  _usePPP_type usePPP;

   typedef uint8_t _aopCfg_type;
  _aopCfg_type aopCfg;

   typedef boost::array<uint8_t, 2>  _reserved5_type;
  _reserved5_type reserved5;

   typedef uint16_t _aopOrbMaxErr_type;
  _aopOrbMaxErr_type aopOrbMaxErr;

   typedef boost::array<uint8_t, 7>  _reserved6_type;
  _reserved6_type reserved6;

   typedef uint8_t _useAdr_type;
  _useAdr_type useAdr;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(CLASS_ID)
  #undef CLASS_ID
#endif
#if defined(_WIN32) && defined(MESSAGE_ID)
  #undef MESSAGE_ID
#endif
#if defined(_WIN32) && defined(MASK1_MIN_MAX)
  #undef MASK1_MIN_MAX
#endif
#if defined(_WIN32) && defined(MASK1_MIN_CNO)
  #undef MASK1_MIN_CNO
#endif
#if defined(_WIN32) && defined(MASK1_INITIAL_FIX_3D)
  #undef MASK1_INITIAL_FIX_3D
#endif
#if defined(_WIN32) && defined(MASK1_WKN_ROLL)
  #undef MASK1_WKN_ROLL
#endif
#if defined(_WIN32) && defined(MASK1_ACK_AID)
  #undef MASK1_ACK_AID
#endif
#if defined(_WIN32) && defined(MASK1_PPP)
  #undef MASK1_PPP
#endif
#if defined(_WIN32) && defined(MASK1_AOP)
  #undef MASK1_AOP
#endif
#if defined(_WIN32) && defined(MASK2_ADR)
  #undef MASK2_ADR
#endif
#if defined(_WIN32) && defined(MASK2_SIG_ATTEN_COMP_MODE)
  #undef MASK2_SIG_ATTEN_COMP_MODE
#endif

  enum {
    CLASS_ID = 6u,
    MESSAGE_ID = 35u,
    MASK1_MIN_MAX = 4u,
    MASK1_MIN_CNO = 8u,
    MASK1_INITIAL_FIX_3D = 64u,
    MASK1_WKN_ROLL = 512u,
    MASK1_ACK_AID = 1024u,
    MASK1_PPP = 8192u,
    MASK1_AOP = 16384u,
    MASK2_ADR = 64u,
    MASK2_SIG_ATTEN_COMP_MODE = 128u,
  };


  typedef boost::shared_ptr< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> const> ConstPtr;

}; // struct CfgNAVX5_

typedef ::ublox_msgs::CfgNAVX5_<std::allocator<void> > CfgNAVX5;

typedef boost::shared_ptr< ::ublox_msgs::CfgNAVX5 > CfgNAVX5Ptr;
typedef boost::shared_ptr< ::ublox_msgs::CfgNAVX5 const> CfgNAVX5ConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ublox_msgs::CfgNAVX5_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ublox_msgs::CfgNAVX5_<ContainerAllocator1> & lhs, const ::ublox_msgs::CfgNAVX5_<ContainerAllocator2> & rhs)
{
  return lhs.version == rhs.version &&
    lhs.mask1 == rhs.mask1 &&
    lhs.mask2 == rhs.mask2 &&
    lhs.reserved1 == rhs.reserved1 &&
    lhs.minSVs == rhs.minSVs &&
    lhs.maxSVs == rhs.maxSVs &&
    lhs.minCNO == rhs.minCNO &&
    lhs.reserved2 == rhs.reserved2 &&
    lhs.iniFix3D == rhs.iniFix3D &&
    lhs.reserved3 == rhs.reserved3 &&
    lhs.ackAiding == rhs.ackAiding &&
    lhs.wknRollover == rhs.wknRollover &&
    lhs.sigAttenCompMode == rhs.sigAttenCompMode &&
    lhs.reserved4 == rhs.reserved4 &&
    lhs.usePPP == rhs.usePPP &&
    lhs.aopCfg == rhs.aopCfg &&
    lhs.reserved5 == rhs.reserved5 &&
    lhs.aopOrbMaxErr == rhs.aopOrbMaxErr &&
    lhs.reserved6 == rhs.reserved6 &&
    lhs.useAdr == rhs.useAdr;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ublox_msgs::CfgNAVX5_<ContainerAllocator1> & lhs, const ::ublox_msgs::CfgNAVX5_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ublox_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> >
{
  static const char* value()
  {
    return "10b967e4bf2a0c03e74705b79c79a211";
  }

  static const char* value(const ::ublox_msgs::CfgNAVX5_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x10b967e4bf2a0c03ULL;
  static const uint64_t static_value2 = 0xe74705b79c79a211ULL;
};

template<class ContainerAllocator>
struct DataType< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ublox_msgs/CfgNAVX5";
  }

  static const char* value(const ::ublox_msgs::CfgNAVX5_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# CFG-NAVX5 (0x06 0x23)\n"
"# Navigation Engine Expert Settings\n"
"#\n"
"# Warning: Refer to u-blox protocol spec before changing these settings.\n"
"\n"
"uint8 CLASS_ID = 6\n"
"uint8 MESSAGE_ID = 35\n"
"\n"
"uint16 version        # Message version (set to 0)\n"
"\n"
"uint16 mask1          # First parameters bitmask (possible values below)\n"
"uint16 MASK1_MIN_MAX        = 4        # apply min/max SVs settings\n"
"uint16 MASK1_MIN_CNO        = 8        # apply minimum C/N0 setting\n"
"uint16 MASK1_INITIAL_FIX_3D = 64       # apply initial 3D fix settings\n"
"uint16 MASK1_WKN_ROLL       = 512      # apply GPS week number rollover settings\n"
"uint16 MASK1_ACK_AID        = 1024     # apply assistance acknowledgment \n"
"                                       # settings\n"
"uint16 MASK1_PPP            = 8192     # apply usePPP flag\n"
"uint16 MASK1_AOP            = 16384    # apply aopCfg (useAOP flag) and \n"
"                                       # aopOrbMaxErr settings\n"
"                                       # (AssistNow Autonomous)\n"
"\n"
"uint32 mask2          # Second parameters bitmask (possible values below)\n"
"                      # Firmware >=8 only\n"
"uint32 MASK2_ADR = 64                    # Apply ADR sensor fusion on/off \n"
"                                         # setting\n"
"uint32 MASK2_SIG_ATTEN_COMP_MODE = 128   # Apply signal attenuation \n"
"                                         # compensation feature settings\n"
"\n"
"uint8[2] reserved1      # Always set to zero\n"
"\n"
"uint8 minSVs            # Minimum number of satellites for navigation\n"
"uint8 maxSVs            # Maximum number of satellites for navigation\n"
"uint8 minCNO            # Minimum satellite signal level for navigation [dBHz]\n"
"\n"
"uint8 reserved2         # Always set to zero\n"
"\n"
"uint8 iniFix3D          # If set to 1, initial fix must be 3D\n"
"\n"
"uint8[2] reserved3      # Always set to zero\n"
"\n"
"uint8 ackAiding         # If set to 1, issue acknowledgments for assistance\n"
"uint16 wknRollover      # GPS week rollover number, GPS week numbers will be set \n"
"                        # correctly from this week up to 1024 weeks after this \n"
"                        # week\n"
"uint8 sigAttenCompMode  # Permanently attenuated signal compensation [dBHz]\n"
"                        # 0 = disabled, 255 = automatic\n"
"                        # 1..63 = maximum expected C/N0 value\n"
"                        # Firmware 8 only\n"
"\n"
"uint8[5] reserved4      # Always set to zero\n"
"\n"
"uint8 usePPP            # Enable/disable PPP (on supported units)\n"
"uint8 aopCfg            # AssistNow Autonomous configuration, 1: enabled\n"
"\n"
"uint8[2] reserved5      # Always set to zero\n"
"\n"
"uint16 aopOrbMaxErr     # Maximum acceptable (modeled) autonomous orbit \n"
"                        # error [m]\n"
"                        # valid range = 5..1000\n"
"                        # 0 = reset to firmware default\n"
"\n"
"uint8[7] reserved6      # Always set to zero\n"
"\n"
"uint8 useAdr            # Enable/disable ADR sensor fusion \n"
"                        # 1: enabled, 0: disabled\n"
"                        # Only supported on certain products \n"
;
  }

  static const char* value(const ::ublox_msgs::CfgNAVX5_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.version);
      stream.next(m.mask1);
      stream.next(m.mask2);
      stream.next(m.reserved1);
      stream.next(m.minSVs);
      stream.next(m.maxSVs);
      stream.next(m.minCNO);
      stream.next(m.reserved2);
      stream.next(m.iniFix3D);
      stream.next(m.reserved3);
      stream.next(m.ackAiding);
      stream.next(m.wknRollover);
      stream.next(m.sigAttenCompMode);
      stream.next(m.reserved4);
      stream.next(m.usePPP);
      stream.next(m.aopCfg);
      stream.next(m.reserved5);
      stream.next(m.aopOrbMaxErr);
      stream.next(m.reserved6);
      stream.next(m.useAdr);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct CfgNAVX5_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ublox_msgs::CfgNAVX5_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ublox_msgs::CfgNAVX5_<ContainerAllocator>& v)
  {
    s << indent << "version: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.version);
    s << indent << "mask1: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.mask1);
    s << indent << "mask2: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mask2);
    s << indent << "reserved1[]" << std::endl;
    for (size_t i = 0; i < v.reserved1.size(); ++i)
    {
      s << indent << "  reserved1[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.reserved1[i]);
    }
    s << indent << "minSVs: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.minSVs);
    s << indent << "maxSVs: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.maxSVs);
    s << indent << "minCNO: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.minCNO);
    s << indent << "reserved2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved2);
    s << indent << "iniFix3D: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.iniFix3D);
    s << indent << "reserved3[]" << std::endl;
    for (size_t i = 0; i < v.reserved3.size(); ++i)
    {
      s << indent << "  reserved3[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.reserved3[i]);
    }
    s << indent << "ackAiding: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ackAiding);
    s << indent << "wknRollover: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.wknRollover);
    s << indent << "sigAttenCompMode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sigAttenCompMode);
    s << indent << "reserved4[]" << std::endl;
    for (size_t i = 0; i < v.reserved4.size(); ++i)
    {
      s << indent << "  reserved4[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.reserved4[i]);
    }
    s << indent << "usePPP: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.usePPP);
    s << indent << "aopCfg: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.aopCfg);
    s << indent << "reserved5[]" << std::endl;
    for (size_t i = 0; i < v.reserved5.size(); ++i)
    {
      s << indent << "  reserved5[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.reserved5[i]);
    }
    s << indent << "aopOrbMaxErr: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.aopOrbMaxErr);
    s << indent << "reserved6[]" << std::endl;
    for (size_t i = 0; i < v.reserved6.size(); ++i)
    {
      s << indent << "  reserved6[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.reserved6[i]);
    }
    s << indent << "useAdr: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.useAdr);
  }
};

} // namespace message_operations
} // namespace ros

#endif // UBLOX_MSGS_MESSAGE_CFGNAVX5_H
