// Auto-generated. Do not edit!

// (in-package ublox_msgs.msg)


"use strict";

const _serializer = _ros_msg_utils.Serialize;
const _arraySerializer = _serializer.Array;
const _deserializer = _ros_msg_utils.Deserialize;
const _arrayDeserializer = _deserializer.Array;
const _finder = _ros_msg_utils.Find;
const _getByteLength = _ros_msg_utils.getByteLength;

//-----------------------------------------------------------

class EsfMEAS {
  constructor(initObj={}) {
    if (initObj === null) {
      // initObj === null is a special case for deserialization where we don't initialize fields
      this.timeTag = null;
      this.flags = null;
      this.id = null;
      this.data = null;
      this.calibTtag = null;
    }
    else {
      if (initObj.hasOwnProperty('timeTag')) {
        this.timeTag = initObj.timeTag
      }
      else {
        this.timeTag = 0;
      }
      if (initObj.hasOwnProperty('flags')) {
        this.flags = initObj.flags
      }
      else {
        this.flags = 0;
      }
      if (initObj.hasOwnProperty('id')) {
        this.id = initObj.id
      }
      else {
        this.id = 0;
      }
      if (initObj.hasOwnProperty('data')) {
        this.data = initObj.data
      }
      else {
        this.data = [];
      }
      if (initObj.hasOwnProperty('calibTtag')) {
        this.calibTtag = initObj.calibTtag
      }
      else {
        this.calibTtag = [];
      }
    }
  }

  static serialize(obj, buffer, bufferOffset) {
    // Serializes a message object of type EsfMEAS
    // Serialize message field [timeTag]
    bufferOffset = _serializer.uint32(obj.timeTag, buffer, bufferOffset);
    // Serialize message field [flags]
    bufferOffset = _serializer.uint16(obj.flags, buffer, bufferOffset);
    // Serialize message field [id]
    bufferOffset = _serializer.uint16(obj.id, buffer, bufferOffset);
    // Serialize message field [data]
    bufferOffset = _arraySerializer.uint32(obj.data, buffer, bufferOffset, null);
    // Serialize message field [calibTtag]
    bufferOffset = _arraySerializer.uint32(obj.calibTtag, buffer, bufferOffset, null);
    return bufferOffset;
  }

  static deserialize(buffer, bufferOffset=[0]) {
    //deserializes a message object of type EsfMEAS
    let len;
    let data = new EsfMEAS(null);
    // Deserialize message field [timeTag]
    data.timeTag = _deserializer.uint32(buffer, bufferOffset);
    // Deserialize message field [flags]
    data.flags = _deserializer.uint16(buffer, bufferOffset);
    // Deserialize message field [id]
    data.id = _deserializer.uint16(buffer, bufferOffset);
    // Deserialize message field [data]
    data.data = _arrayDeserializer.uint32(buffer, bufferOffset, null)
    // Deserialize message field [calibTtag]
    data.calibTtag = _arrayDeserializer.uint32(buffer, bufferOffset, null)
    return data;
  }

  static getMessageSize(object) {
    let length = 0;
    length += 4 * object.data.length;
    length += 4 * object.calibTtag.length;
    return length + 16;
  }

  static datatype() {
    // Returns string type for a message object
    return 'ublox_msgs/EsfMEAS';
  }

  static md5sum() {
    //Returns md5sum for a message object
    return '2ee2c25c5689cb0a12cc22f118ece178';
  }

  static messageDefinition() {
    // Returns full string definition for message
    return `
    # ESF-MEAS (0x10 0x02)
    # External Sensor Fusion Measurements
    # 
    # Possible data types for the data field are described in the ESF Measurement 
    # Data section
    #
    
    uint8 CLASS_ID = 16
    uint8 MESSAGE_ID = 2
    
    uint32 timeTag               # Time tag of measurement generated by external 
                                 # sensor
    
    uint16 flags                 # Flags. Set all unused bits to zero:
    uint16 FLAGS_TIME_MARK_SENT_MASK = 3   # Time mark signal was supplied just 
                                           # prior to sending this message: 0 =
    uint16 TIME_MARK_NONE = 0
    uint16 TIME_MARK_EXT0 = 1
    uint16 TIME_MARK_EXT = 2
    uint16 FLAGS_TIME_MARK_EDGE = 4        # Trigger on rising (0) or falling 
                                           # (1) edge of time mark signal
    uint16 FLAGS_CALIB_T_TAG_VALID = 8     # Calibration time tag available. 
                                           # Always set to zero.
    
    uint16 id                              # Identification number of data provider
    
    # Start of repeated block (N times)
    uint32[] data                # data, see mask below
    uint32 DATA_FIELD_MASK = 16777215     # data
    uint32 DATA_TYPE_MASK = 1056964608    # type of data (1..63)
    uint32 DATA_TYPE_SHIFT = 24
    uint32 DATA_TYPE_NONE = 0                     # data field contains no data
    uint32 DATA_TYPE_Z_AXIS_GYRO = 5              # z-axis gyroscope angular rate 
                                                  # [deg/s *2^-12 signed]
    uint32 DATA_TYPE_WHEEL_TICKS_FRONT_LEFT = 6   # front-left wheel ticks 
                                                  # Bits 0-22: unsigned tick value. 
                                                  # Bit 23: direction indicator 
                                                  # (0=forward, 1=backward)
    uint32 DATA_TYPE_WHEEL_TICKS_FRONT_RIGHT = 7  # front-right wheel ticks 
                                                  # Bits 0-22: unsigned tick value. 
                                                  # Bit 23: direction indicator 
                                                  # (0=forward, 1=backward)
    uint32 DATA_TYPE_WHEEL_TICKS_REAR_LEFT = 8    # rear-left wheel ticks 
                                                  # Bits 0-22: unsigned tick value. 
                                                  # Bit 23: direction indicator 
                                                  # (0=forward, 1=backward)
    uint32 DATA_TYPE_WHEEL_TICKS_REAR_RIGHT = 9   # rear-right wheel ticks 
                                                  # Bits 0-22: unsigned tick value. 
                                                  # Bit 23: direction indicator 
                                                  # (0=forward, 1=backward)
    uint32 DATA_TYPE_SINGLE_TICK = 10             # single tick (speed tick) 
                                                  # Bits 0-22: unsigned tick value. 
                                                  # Bit 23: direction indicator 
                                                  # (0=forward, 1=backward)
    uint32 DATA_TYPE_SPEED = 11                   # speed m/s * 1e-3 signed
    uint32 DATA_TYPE_GYRO_TEMPERATURE = 12        # gyroscope temperature 
                                                  # [deg Celsius * 1e-2 signed]
    uint32 DATA_TYPE_GYRO_ANG_RATE_Y = 13         # y-axis gyroscope angular rate 
                                                  # [deg/s *2^-12 signed]
    uint32 DATA_TYPE_GYRO_ANG_RATE_X = 14         # x-axis gyroscope angular rate 
                                                  # [deg/s *2^-12 signed]
    uint32 DATA_TYPE_ACCELEROMETER_X = 16         # x-axis accelerometer specific 
                                                  # [force m/s^2 *2^-10 signed]
    uint32 DATA_TYPE_ACCELEROMETER_Y = 17         # y-axis accelerometer specific 
                                                  # [force m/s^2 *2^-10 signed]
    uint32 DATA_TYPE_ACCELEROMETER_Z = 18         # z-axis accelerometer specific 
                                                  # [force m/s^2 *2^-10 signed]
    
    
    
    # End of repeated block
    
    # Start of optional block (size is either 0 or 1)
    uint32[] calibTtag           # Receiver local time calibrated.
                                 # This field must not be supplied when
                                 # calibTtagValid is set to 0 [ms]
    # End of optional block
    `;
  }

  static Resolve(msg) {
    // deep-construct a valid message object instance of whatever was passed in
    if (typeof msg !== 'object' || msg === null) {
      msg = {};
    }
    const resolved = new EsfMEAS(null);
    if (msg.timeTag !== undefined) {
      resolved.timeTag = msg.timeTag;
    }
    else {
      resolved.timeTag = 0
    }

    if (msg.flags !== undefined) {
      resolved.flags = msg.flags;
    }
    else {
      resolved.flags = 0
    }

    if (msg.id !== undefined) {
      resolved.id = msg.id;
    }
    else {
      resolved.id = 0
    }

    if (msg.data !== undefined) {
      resolved.data = msg.data;
    }
    else {
      resolved.data = []
    }

    if (msg.calibTtag !== undefined) {
      resolved.calibTtag = msg.calibTtag;
    }
    else {
      resolved.calibTtag = []
    }

    return resolved;
    }
};

// Constants for message
EsfMEAS.Constants = {
  CLASS_ID: 16,
  MESSAGE_ID: 2,
  FLAGS_TIME_MARK_SENT_MASK: 3,
  TIME_MARK_NONE: 0,
  TIME_MARK_EXT0: 1,
  TIME_MARK_EXT: 2,
  FLAGS_TIME_MARK_EDGE: 4,
  FLAGS_CALIB_T_TAG_VALID: 8,
  DATA_FIELD_MASK: 16777215,
  DATA_TYPE_MASK: 1056964608,
  DATA_TYPE_SHIFT: 24,
  DATA_TYPE_NONE: 0,
  DATA_TYPE_Z_AXIS_GYRO: 5,
  DATA_TYPE_WHEEL_TICKS_FRONT_LEFT: 6,
  DATA_TYPE_WHEEL_TICKS_FRONT_RIGHT: 7,
  DATA_TYPE_WHEEL_TICKS_REAR_LEFT: 8,
  DATA_TYPE_WHEEL_TICKS_REAR_RIGHT: 9,
  DATA_TYPE_SINGLE_TICK: 10,
  DATA_TYPE_SPEED: 11,
  DATA_TYPE_GYRO_TEMPERATURE: 12,
  DATA_TYPE_GYRO_ANG_RATE_Y: 13,
  DATA_TYPE_GYRO_ANG_RATE_X: 14,
  DATA_TYPE_ACCELEROMETER_X: 16,
  DATA_TYPE_ACCELEROMETER_Y: 17,
  DATA_TYPE_ACCELEROMETER_Z: 18,
}

module.exports = EsfMEAS;
